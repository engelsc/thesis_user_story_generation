import subprocess
from typing import cast
from bs4 import BeautifulSoup
import pandas as pd
import re


DEFAULT_AQUSA_SCRIPT_PATH = "./aqusa-core/aqusacore.py"
DEFAULT_PYTHON_EXECUTABLE = "./.venv3.8/bin/python"


######################
# MAIN ORCHESTRATOR FUNCTION
######################
def process_with_aqusacore(
    user_stories: pd.DataFrame,
    run_amount: int = 1,
    aqusa_format: str = "txt",
    tmp_stories_path: str = "user_stories.txt",
    tmp_output_path: str = "user_stories_evaluated",

) -> pd.DataFrame:
    """
    Writes user stories from given DataFrame to a plain text file, runs AQUSA core
    and then parses the results.
    """
    prepare_user_stories(user_stories, f"input/{tmp_stories_path}", run_amount)

    run_aqusacore(tmp_stories_path, tmp_output_path, aqusa_format)

    user_stories_parsed: pd.DataFrame
    if aqusa_format.lower() == "txt":
        user_stories_parsed = parse_user_stories_txt(f"output/{tmp_output_path}.txt")
    else:
        user_stories_parsed = parse_user_stories_html(f"output/{tmp_output_path}.html")

    return user_stories_parsed


######################
# HELPER FUNCTIONS
######################
def run_aqusacore(
    input_file: str,
    output_file: str,
    output_format: str = "txt",
    python_executable : str = DEFAULT_PYTHON_EXECUTABLE,
    aqusa_path: str = DEFAULT_AQUSA_SCRIPT_PATH,
) -> None:
    """
    Runs the aqusa-core script via a subprocess call.
    :param input_file: Path to the text file containing user stories.
    :param output_file: Path where the aqusa-core will write its output.
    :param output_format: 'txt' or 'html'.
    :param python_executable: Path to the Python interpreter that has the dependencies installed.
    :param aqusa_path: The path to the aqusa-core script.
    """

    command: list[str] = [
        python_executable,
        aqusa_path,
        "-i", input_file,
        "-o", output_file,
        "-f", output_format,
    ]

    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        print("Command ran successfully:")
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        error_message = e.stderr if e.stderr else "Unknown error (no stderr output)"
        print(f"Error running aqusa-core: {error_message}")
        raise


def prepare_user_stories(
	user_stories: pd.DataFrame,
    output_path: str,
    run_amount: int = 1,
) -> None:
	"""
    Writes user stories from a DataFrame to a text file for AQUSA processing.
    Expects a DataFrame where the first column contains the user stories.
    :param user_stories: DataFrame containing user stories in first column.\n
    :param output_path: File path to write the user stories.\n
    :param run_amount: (Optional) The number of user stories generated per row.
    """

	pattern = re.compile(r"[\"'\n\r]")
	with open(output_path, "w", encoding="utf-8") as file:
		for story in user_stories.iloc[:,0]:
			cleaned_story = re.sub(pattern, "", story).strip()
			file.write(f"{cleaned_story}\n")



def parse_user_stories_txt(
	file_path: str
) -> pd.DataFrame:
    """
    Parser that reads a TXT file generated by AQUSA and extracts:
      - story_id
      - user_story
      - defect_type
      - sub_type
      - message
    Prefer this over HTML parsing if possible.
    :param file_path: The path to the TXT file.
    :return: DataFrame of parsed results.
    """

    data = []

    with open(file_path, "r", encoding="utf-8") as file:
        story_id = None
        user_story = None
        defect_type = None
        sub_type = None
        message = None

        for line in file:
            # Match the story ID and user story
            story_match = re.match(r'^Story #(\d+): "(.*)"$', line.strip())
            if story_match:
                try:
                    story_id = cast(int, story_match.group(1)) if story_match else None
                except ValueError:
                    story_id = None # Handles malformed input, not castable into int
                user_story = str(story_match.group(2)) if story_match else None
                continue

            # Match the defect type and sub_type
            defect_match = re.match(
                r"^\s*Defect type: ([^\.]+)\.([^ ]+)$", line.strip()
            )
            if defect_match:
                defect_type = str(defect_match.group(1)) if defect_match else "Unknown"
                sub_type = str(defect_match.group(2)) if defect_match else "Unknown"
                continue

            # Match the message
            message_match = re.match(r"^\s*Message: (.*)$", line.strip())
            if message_match:
                message = str(message_match.group(1)) if message_match else "No message"

                data.append(
                    [
                        story_id,
                        user_story,
                        defect_type,
                        sub_type,
                        message,
                    ]
                )

    # Create a DataFrame
    df = pd.DataFrame(
        data, columns=["story_id", "user_story", "defect_type", "sub_type", "message"]
    )
    return df


def parse_user_stories_html(
	file_path: str
) -> pd.DataFrame:
    """
    Parser that reads an HTML file generated by AQUSA and extracts:
      - story_id
      - user_story
      - defect_type
      - sub_type
      - message
    If possible, choose TXT parser.
    :param file_path: The path to the HTML file.
    :return: DataFrame of parsed results.
    """

    with open(file_path, "r") as file:
        soup = BeautifulSoup(file, "html.parser")

    data = []
    table = soup.find("table", {"class": "sortable"})
    if not table:
        print(f"Warning: No table found in {file_path}. Returning empty DataFrame.")
        return pd.DataFrame(columns=["story_id", "user_story", "defect_type", "sub_type", "message"])

	# Skip header row
    rows = table.find_all("tr")[1:]  # type: ignore

    for row in rows:
        cols = row.find_all("td")
        story_id = cols[0].text
        user_story = cols[1].text
        defect_type = cols[2].text
        sub_type = cols[3].text
        message = cols[4].text
        data.append([story_id, user_story, defect_type, sub_type, message])

    df = pd.DataFrame(
        data, columns=["story_id", "user_story", "defect_type", "sub_type", "message"]
    )
    return df
