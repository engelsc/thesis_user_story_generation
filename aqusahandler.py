import subprocess
from typing import cast
from bs4 import BeautifulSoup
import pandas as pd
import re


DEFAULT_AQUSA_SCRIPT_PATH = "./aqusa-core/aqusacore.py"
DEFAULT_PYTHON_EXECUTABLE = "./.venv3.8/bin/python"


######################
# MAIN ORCHESTRATOR FUNCTION
######################
def process_with_aqusacore(
    response_data: pd.DataFrame,
    run_amount: int = 1,
    aqusa_format: str = "txt",
    tmp_stories_path: str = "user_stories.txt",
    tmp_output_path: str = "user_stories_evaluated",

) -> pd.DataFrame:
    prepare_user_stories(response_data, f"input/{tmp_stories_path}", run_amount)

    run_aqusacore(tmp_stories_path, tmp_output_path, aqusa_format)

    user_stories_parsed: pd.DataFrame
    if aqusa_format.lower() == "txt":
        user_stories_parsed = parse_user_stories_txt(f"output/{tmp_output_path}.txt")
    else:
        user_stories_parsed = parse_user_stories_html(f"output/{tmp_output_path}.html")

    return user_stories_parsed


######################
# HELPER FUNCTIONS
######################
def run_aqusacore(
    input_file: str,
    output_file: str,
    output_format: str = "txt",
    python_executable : str = DEFAULT_PYTHON_EXECUTABLE,
    aqusa_path: str = DEFAULT_AQUSA_SCRIPT_PATH,
) -> None:
    """
    Runs the aqusa-core script via a subprocess call.
    :param input_file: Path to the text file containing user stories.
    :param output_file: Path where the aqusa-core will write its output.
    :param output_format: 'txt' or 'html'.
    :param python_executable: Path to the Python interpreter that has the dependencies installed.
    :param aqusa_path: The path to the aqusa-core script.
    """

    command: list[str] = [
        python_executable,
        aqusa_path,
        "-i", input_file,
        "-o", output_file,
        "-f", output_format,
    ]

    try:
        result = subprocess.run(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, check=True)
        print("Command ran successfully:")
        print(result.stdout)
    except subprocess.CalledProcessError as e:
        error_message = e.stderr if e.stderr else "Unknown error (no stderr output)"
        print(f"Error running aqusa-core: {error_message}")
        raise


def prepare_user_stories(
    response: pd.DataFrame,
    output_path: str,
    run_amount: int = 1,
    story_prefix: str = "story_",
) -> None:
    """
    Extracts user story columns from the given DataFrame (story_1, story_2, etc.)
    and writes them to a plain text file line-by-line, suitable for AQUSA input.
    :param response: DataFrame containing user story columns.
    :param output_path: File path to write the user stories.
    :param run_amount: The number of user stories generated per row.
    :param story_prefix: The column prefix used for user stories.
    """

    with open(output_path, "w", encoding="utf-8") as file:
        # for each row in response, gather the user stories.
        # each story is written on its own line in a text file.
        for _, row in response.iterrows():
            for i in range(run_amount):
                col = f"{story_prefix}{i+1}" # -> column name = story_1
                if col in row and pd.notna(row[col]):
                    # remove extra quotes/newlines
                    user_story = str(row[col]).replace('"', "").replace("'", "").replace("\n", " ").replace("\r", " ").strip()
                    file.write(f"{user_story}\n")


def parse_user_stories_txt(
	file_path: str
) -> pd.DataFrame:
    """
    Parser that reads a TXT file generated by AQUSA and extracts:
      - story_id
      - user_story
      - defect_type
      - sub_type
      - message
    Prefer this over HTML parsing if possible.
    :param file_path: The path to the TXT file.
    :return: DataFrame of parsed results.
    """

    data = []

    with open(file_path, "r", encoding="utf-8") as file:
        story_id = None
        user_story = None
        defect_type = None
        sub_type = None
        message = None

        for line in file:
            # Match the story ID and user story
            story_match = re.match(r'^Story #(\d+): "(.*)"$', line.strip())
            if story_match:
                try:
                    story_id = cast(int, story_match.group(1)) if story_match else None
                except ValueError:
                    story_id = None # Handles malformed input, not castable into int
                user_story = str(story_match.group(2)) if story_match else None
                continue

            # Match the defect type and sub_type
            defect_match = re.match(
                r"^\s*Defect type: ([^\.]+)\.([^ ]+)$", line.strip()
            )
            if defect_match:
                defect_type = str(defect_match.group(1)) if defect_match else "Unknown"
                sub_type = str(defect_match.group(2)) if defect_match else "Unknown"
                continue

            # Match the message
            message_match = re.match(r"^\s*Message: (.*)$", line.strip())
            if message_match:
                message = str(message_match.group(1)) if message_match else "No message"

                data.append(
                    [
                        story_id,
                        user_story,
                        defect_type,
                        sub_type,
                        message,
                    ]
                )

    # Create a DataFrame
    df = pd.DataFrame(
        data, columns=["story_id", "user_story", "defect_type", "sub_type", "message"]
    )
    return df


def parse_user_stories_html(
	file_path: str
) -> pd.DataFrame:
    """
    Parser that reads an HTML file generated by AQUSA and extracts:
      - story_id
      - user_story
      - defect_type
      - sub_type
      - message
    If possible, choose TXT parser.
    :param file_path: The path to the HTML file.
    :return: DataFrame of parsed results.
    """

    with open(file_path, "r") as file:
        soup = BeautifulSoup(file, "html.parser")

    data = []
    table = soup.find("table", {"class": "sortable"})
    if not table:
        print(f"Warning: No table found in {file_path}. Returning empty DataFrame.")
        return pd.DataFrame(columns=["story_id", "user_story", "defect_type", "sub_type", "message"])

    rows = table.find_all("tr")[1:]  # Skip header row

    for row in rows:
        cols = row.find_all("td")
        story_id = cols[0].text
        user_story = cols[1].text
        defect_type = cols[2].text
        sub_type = cols[3].text
        message = cols[4].text
        data.append([story_id, user_story, defect_type, sub_type, message])

    df = pd.DataFrame(
        data, columns=["story_id", "user_story", "defect_type", "sub_type", "message"]
    )
    return df
